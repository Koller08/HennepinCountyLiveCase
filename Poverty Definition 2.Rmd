---
title: "Poverty definition"
author: "Tzu-Hsuan (Jessica) Lin"
date: "2020/11/21"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
#setwd("D:/UMN/06_6130 Introduction to Business Analytics in R/Hennepin County Live Case")
```

```{r warning=FALSE, message=FALSE}
library(tidyverse)
library(dplyr)
library(readxl)
library(tidyr)
library(ggplot2)
```

# General
## Read in all data
FFIEC dataset contains 2020 estimations for population and median income per tract.
Census data is used for ethnicity distribution (which we haven't used for now).
```{r message=FALSE}
ffiec <- read_excel('2020 FFIEC Summary Census Demographic Information.xlsx')
snap <- read_excel('SNAP Summary data for LiveCase fall 2020.xlsx')
census <- read_csv('2010_Census_Tracts.csv')
```

## Merge and select required columns
```{r}
df <- snap %>%
  full_join(census, by = c('tract' = 'GEOID10'), suffix = c('snap', 'census'))
df <- df %>%
  full_join(ffiec, by = c('NAME10' = 'Tract Code'), suffix = c('df', 'ffiec'))
df <- df %>%
  select('elig_month', 'tract', 'NAME10', 'race_ethnicity', 'people', 'ALAND10',
         'TRACT', 'POP_TOTAL', 'POP1_RACE', 'POP1_WHT', 'POP1_BLK',
         'POP1_AMIND', 'POP1_ASN', 'POP1_HAWPA',  'POP1_OTHR', 'POP2_MORE',
         'POP_HSPLAT', 'POP_NO_HSP', 'POPWHNOHSP', 'TOT_HU', 'TOT_OCCHU',
         'TOT_VACHU', 'Tract Income Level',
         '2020 Est. Tract Median Family Income', 'Tract Population') %>%
  rename('median_income_ffiec' = '2020 Est. Tract Median Family Income',
         'pop_ffiec' = 'Tract Population'
         )
```


## Filter by 2019 and ignore unknown income level for now
Since FFIEC data set is 2020 estimation, I subset 2019 dataset so that the estimation does not be too different from reality.
```{r}
df_2019 <- df %>%
  filter(elig_month > '2018-12-31', elig_month < '2020-01-01')
df_2019 <- df_2019 %>%
  filter(`Tract Income Level` != 'Unknown')
```


## Reading household size per tract data
With help from Casey's team, I extracted the size and margin error of household in each tract in 2018.
```{r message=FALSE, warning=FALSE}
tract <- read_excel("hennepin_county_all_tracts_household_size_us_census_2018 - Copy.xlsx", skip=9)
tract <- tract[3, grepl("Tract", names(tract))]
tract <- gather(tract)
tract$key <- gsub(", Hennepin County, Minnesota", "", tract$key)
tract$key <- gsub("Census Tract ", "", tract$key)
tract$value <- gsub(",", "", tract$value)
tract$key <- as.numeric(tract$key)
tract$value <- as.numeric(tract$value)
tract <- tract %>%
  rename(tract_name = key,
         household_size = value)
# tract household margin
margin <- read_excel("hennepin_county_all_tracts_household_size_us_census_2018 - Copy.xlsx",
                    skip=9)
margin <- margin[3,]
margin <- gather(margin)
margin <- margin[grepl("±",margin$value), ]
margin$value <- gsub("±", "", margin$value)
margin$key <- as.numeric(margin$key)
margin$value <- as.numeric(margin$value)
margin <- margin %>%
  rename(household_margin = value)
tract <- cbind(tract, margin$household_margin)
tract <- tract %>%
  rename(household_margin = `margin$household_margin`)
```

## Join household size with main df and calculate people per household
```{r}
df_2019 <- df_2019%>%
  left_join(tract, by=c('NAME10' = 'tract_name'))
df_2019['ppl_per_household'] <- df_2019['pop_ffiec'] / df_2019['household_size']

#df_2019 <- df_2019 %>%
  #rename('White' = 'POP1_WHT',
         #'Black/African American' = 'POP1_BLK',
         #'American Indian or Alaskan Native' = 'POP1_AMIND',
         #'Asian/Pacific Islander' = 'POP1_ASN',
         #'Native Hawaiian and Other Pacific Islander' = 'POP1_HAWPA')
```


## Join household size with main df and calculate people per household
```{r}
df <- df%>%
  left_join(tract, by=c('NAME10' = 'tract_name'))
df['ppl_per_household'] <- df['pop_ffiec'] / df['household_size']

#df_2019 <- df_2019 %>%
  #rename('White' = 'POP1_WHT',
         #'Black/African American' = 'POP1_BLK',
         #'American Indian or Alaskan Native' = 'POP1_AMIND',
         #'Asian/Pacific Islander' = 'POP1_ASN',
         #'Native Hawaiian and Other Pacific Islander' = 'POP1_HAWPA')
```
## income limit function
With clearer definition of how the income limit should be set, I thought we could leverage the linear model funtion and find out the exact limit for each tract's household. (eg, avg 1.7 people per household, then the monthly income limit is roughly 2186)
```{r message=FALSE, warning=FALSE}
limit <- c(1755, 2371, 2987, 3603, 4219, 4835, 5451, 6067)
ppl <- c(1, 2 ,3, 4, 5, 6, 7, 8)
income <- data.frame(ppl, limit)
ggplot(income, aes(x=ppl, y=limit))+geom_point()
summary(lm(limit~ppl))
# income limit function: limit= 1139 + 616 * ppl
```


## estimating income limit per tract
With the previous function, here I am estimating the annual income limit for each tract.
```{r}
df['monthly_income_limit'] <- 1139 + 616 * df['ppl_per_household']
df['annual_income_limit'] <- df['monthly_income_limit'] * 12
```

## estimating income limit per tract
With the previous function, here I am estimating the annual income limit for each tract.
```{r}
df_2019['monthly_income_limit'] <- 1139 + 616 * df_2019['ppl_per_household']
df_2019['annual_income_limit'] <- df_2019['monthly_income_limit'] * 12
```


## reading in income level by ethnicity
```{r message=FALSE, warning=FALSE}
ethnicity <- read_excel("ACSST1Y2019.S1903-2020-11-25T211057.xlsx", skip=11)
ethnicity <- ethnicity[, c(1, 6, 7)]
ethnicity <- ethnicity %>%
  rename(median_income_ethnicity = `Estimate...6`,
         margin_income_ethnicity = `Margin of Error...7`)
ethnicity$Label <- gsub("(^[[:space:]]+|[[:space:]]+$)", "", ethnicity$Label)
ethnicity$margin_income_ethnicity <- gsub("±", "",
                                          ethnicity$margin_income_ethnicity)
ethnicity$median_income_ethnicity <- gsub(',', "",
                                          ethnicity$median_income_ethnicity)
ethnicity$margin_income_ethnicity <- gsub(',', "",
                                          ethnicity$margin_income_ethnicity)
ethnicity$median_income_ethnicity <- as.numeric(ethnicity$median_income_ethnicity)
ethnicity$margin_income_ethnicity <- as.numeric(ethnicity$margin_income_ethnicity)
ethnicity <- ethnicity[4:12, ]
# replace names
ethnicity$Label <- gsub("Black or African American",
                        "Black/African American",
                        ethnicity$Label)
ethnicity$Label <- gsub("American Indian and Alaska Native",
                        "American Indian or Alaskan Native",
                        ethnicity$Label)
ethnicity$Label <- gsub("Asian",
                        "Asian/Pacific Islander",
                        ethnicity$Label)
ethnicity$Label <- gsub("Some other race",
                        "Other or Unknown",
                        ethnicity$Label)
ethnicity$Label <- gsub("Hispanic or Latino origin (of any race)",
                        "Hispanic or Latino",
                        ethnicity$Label,
                        fixed=TRUE)
```


## merge it to df_2019
```{r}
df_2019 <- df_2019 %>%
  left_join(ethnicity, by=c('race_ethnicity' = 'Label'))
```


## merge it to df
```{r}
df <- df %>%
  left_join(ethnicity, by=c('race_ethnicity' = 'Label'))
```


-------------------------------------------------
# Method 1 (DO NOT RUN)
## Using log-normal to estimate percentage <32K (assuming 2.5 ppl per household)
This is the older version of how I calculate "how many people are eligible".
Don't run this chunk for now. This one is definitely wrong.
```{r}
# standard deviation from
# Median Household Income by State - 3 Year Average
# https://www.census.gov/data/tables/time-series/demo/income-poverty/historical-income-households.html
# 2774 for MN
# log-normal reference
# https://www.mathworks.com/help/stats/lognormal-distribution.html
# http://www.statlit.org/pdf/2018-Schield-ASA.pdf
# https://en.wikipedia.org/wiki/Log-normal_distribution#Cumulative_distribution_function
perc <- c()
for (i in 1:nrow(df_2019)){
  
  income <- as.numeric(df_2019[i,'median_income_ffiec'])
  perc_single <- plnorm(32000, meanlog = log(income),
                        sdlog = sqrt(log((2774*2774/income)^2 + 1)))
  # print(perc_single)
  perc = c(perc, perc_single)
  
}
# plnorm(32000, meanlog = log(66855), sdlog = sqrt(log((2744*2744/66855)^2 + 1)))
df_2019 <- df_2019 %>%
  cbind(perc)
df_2019['pop<32K'] <- round(df_2019['pop_ffiec'] * df_2019['perc'],0)
df_2019['snap_perc'] <- round(df_2019['people'] / df_2019['pop<32K'],2)
```





-------------------------------------------------
# Method 2
## Using FFIEC income per tract to estimate how many people are under respective income limit
If we plot this final df_2019, you can see that there are snap_percentages > 1 (Max is around 1.7), and most of these are African American community. This implies we need to more accurately estimate the median income for each tract and each ethnicity.
(Eg. Now for tract 27053106400, we have its median income of 73569, for all ethnicity. However, the median income for African American community in this tract might be lower than 70K, and the reason it can reach a median of 70K is probably because there are a lot of white households who earn more than African American people. Thus we are under-estimating the potential eligible African American people in this tract).
```{r}
pop_perc_by_tract_income <- c()
for (i in 1:nrow(df_2019)){
  
  income <- as.numeric(df_2019[i,'median_income_ffiec'])
  limit <- as.numeric(df_2019[i,'monthly_income_limit'])
  # error <- as.numeric(df_2019[i,'error'])
  
  perc_single <- plnorm(limit, meanlog = log(income),
                        sdlog = sqrt(log((2774*2774/income)^2 + 1)))
  # print(perc_single)
  pop_perc_by_tract_income = c(pop_perc_by_tract_income, perc_single)
  
}
df_2019 <- df_2019 %>%
  cbind(pop_perc_by_tract_income)
df_2019['pop_limit_by_tract_income'] <- round(df_2019['pop_ffiec'] *
                                         df_2019['pop_perc_by_tract_income'],0)
df_2019['snap_perc_by_tract_income'] <- round(df_2019['people'] /
                                df_2019['pop_limit_by_tract_income'],2)
```




-------------------------------------------------
# Method 3
## Using county-level income per ethnicity to estimate how many people are under respective income limit
With income per ethnicity for Hennepin county (found at US census bureau), I tried to re-do the calculation based on "different ethnicity has different income level". That is, assuming people's income is determined by ethnicity, not by tract. (Method 2 was determined by tract - every ethnicity in that tract got the same income level).
But it seems that this is still not the best calculation method, although it does seem more reasonable than Method 2. The max snap penetration rate is still larger than 1 (1.5 for now), but most of them are already lower than 1.
```{r}
pop_perc_by_ethnicity_income <- c()
for (i in 1:nrow(df)){
  
  income <- as.numeric(df[i,'median_income_ethnicity'])
  limit <- as.numeric(df[i,'monthly_income_limit'])
  error <- as.numeric(df[i,'margin_income_ethnicity'])
  
  perc_single <- plnorm(limit, meanlog = log(income),
                        sdlog = sqrt(log((error*error/income)^2 + 1)))
  #print(perc_single)
  pop_perc_by_ethnicity_income = c(pop_perc_by_ethnicity_income, perc_single)
  
}
df <- df %>%
  cbind(pop_perc_by_ethnicity_income)
df['pop_limit_by_ethnicity_income'] <- round(df['pop_ffiec'] *
                                     df['pop_perc_by_ethnicity_income'],0)
df['snap_perc_by_ethnicity_income'] <- round(df['people'] /
                                    df['pop_limit_by_ethnicity_income'],2)

```
## estimating income limit per tract
With the previous funtion, here I am estimating the annual income limit for each tract.
```{r}
df['limit'] <- 1139 + 616 * df['ppl_per_household']
df['annual_income_limit'] <- df['limit'] * 12
```




## Re-calculate how many people are under respective income limit
If we plot this final df_2019, you can see that there are snap_percentages > 1 (Max is around 1.7), and most of these are African American community. This implies we need to more accurately estimate the median income for each tract and each ethnicity.
(Eg. Now for tract 27053106400, we have its median income of 73569, for all ethnicity. However, the median income for African American community in this tract might be lower than 70K, and the reason it can reach a median of 70K is probably because there are a lot of white households who earn more than African American people. Thus we are under-estimating the potential eligible African American people in this tract).
```{r}
perc <- c()
for (i in 1:nrow(df_2019)){
  
  income <- as.numeric(df_2019[i,'2020_median_fam_income'])
  limit <- as.numeric(df_2019[i,'limit'])
  # error <- as.numeric(df_2019[i,'error'])
  
  perc_single <- plnorm(limit, meanlog = log(income),
                        sdlog = sqrt(log((2774*2774/income)^2 + 1)))
  # print(perc_single)
  perc = c(perc, perc_single)
  
}
df_2019 <- df_2019 %>%
  cbind(perc)
df_2019['pop<limit'] <- round(df_2019['pop_ffiec'] * df_2019['perc'],0)
df_2019['snap_perc'] <- round(df_2019['people'] / df_2019['pop<limit'],2)
```



```{r}
#write.csv(df_2019, "C:\\Users\\kadzi\\Documents\\df_2019.csv", row.names = TRUE)
```

```{r}
#df_2019_percent_usingSNAP <- read_csv("df_2019_percent_usingSNAP.csv")

#df_2019_percent_usingSNAP <- df_2019_percent_usingSNAP %>%
                                #filter(elig_month == '2019-12-01')
#write.csv(df, "C:\\Users\\kadzi\\OneDrive\\UOFM\\Fall Semester 2020\\Live Case\\df.csv", row.names = TRUE)
```

-------------------------------------------------
# Method 4
## Adjust tract income based on ethnicity income ratio
I think I finally sorted my mind out, but it's still not the answer I was looking for...
The idea is to use a ratio, based on ethnicity. `ethnicity_avg` is the average of 6 ethnicities (that appeared in the snap dataset). Then, ethnicity income / average income for all ethnicity would give me a ratio (like white people are earning 90321 / 63151.33 = 1.43 more than average). Then, for each tract, use their tract income to multiply its ratio. Thus give me an adjusted income.
Then still apply it to previous ideas of calculating "how many people are under its respective income limit". Max value is still 1.5...

```{r}
# calculate average for all ethnicity
ethnicity_avg <- ethnicity %>%
  filter((Label == 'White') | (Label == 'Black/African American') | 
           (Label == 'American Indian or Alaskan Native') |
           (Label == 'Asian/Pacific Islander') | 
           (Label == 'Other or Unknown') | (Label == 'Hispanic or Latino')) %>%
  summarize(avg = mean(median_income_ethnicity),
            std = sd(margin_income_ethnicity))
df_2019 <- cbind(df_2019, ethnicity_avg)
df_2019['adjusted_income'] <- (df_2019['median_income_ffiec'] * 
                                 df_2019['median_income_ethnicity'] / 
                                 df_2019['avg'])
pop_perc_by_adjusted_income <- c()
for (i in 1:nrow(df_2019)){
  
  income <- as.numeric(df_2019[i,'adjusted_income'])
  limit <- as.numeric(df_2019[i,'monthly_income_limit'])
  error <- as.numeric(df_2019[i,'margin_income_ethnicity'])
  
  perc_single <- plnorm(limit, meanlog = log(income),
                        sdlog = sqrt(log((error*error/income)^2 + 1)))
  # print(perc_single)
  pop_perc_by_adjusted_income = c(pop_perc_by_adjusted_income, perc_single)
  
}
df_2019 <- df_2019 %>%
  cbind(pop_perc_by_adjusted_income)
df_2019['pop_limit_by_adjusted_income'] <- round(df_2019['pop_ffiec'] *
                                     df_2019['pop_perc_by_adjusted_income'],0)
df_2019['snap_perc_by_adjusted_income'] <- round(df_2019['people'] /
                                    df_2019['pop_limit_by_adjusted_income'],2)
```



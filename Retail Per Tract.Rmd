---
title: "Retail Per Tract"
author: "Tzu-Hsuan (Jessica) Lin"
date: "2020/11/20"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
setwd("D:/UMN/06_6130 Introduction to Business Analytics in R/Hennepin County Live Case")
```

```{r warning=FALSE, message=FALSE}
library(tidyverse)
library(dplyr)
library(rgdal)
```


# Read Shape File
Using `readOGR()` function from the rgdal package to tackle the geometry shape.
```{r}
hennepin = readOGR(dsn = "map_data", layer = "2010_Census_Tracts")
```

## Read Retail Data
Read in the retails store data and select only those in Hennepin, MN.
```{r warning=FALSE, message=FALSE}
retail_US <- read_csv("SNAP_Store_Locations.csv")
retail_US$Zip5 <- as.numeric(retail_US$Zip5)
retail <- retail_US %>%
  filter(State == 'MN', County == 'HENNEPIN')
```


## Convert to spdf
Since retail data uses WSG84 projection as location (the common seen latitude, longitude) and the Hennepin tract geometry uses UTM zone 15 (epsg: 32615) to record the exact location, it is necessary to convert the two into the same CRS (
Coordinate Reference System).
```{r}
# concept reference: https://epsg.io/32615
# concept reference: https://datacarpentry.org/organization-geospatial/03-crs/

# code reference
# http://rstudio-pubs-static.s3.amazonaws.com/19879_7e13ab80d5ed416c8e235bd6bb93cf3e.html

cord.dec <- SpatialPoints(retail[, c("Longitude", "Latitude")], 
                          proj4string = CRS("+proj=longlat"))

lnglat <- spTransform(cord.dec, hennepin@proj4string@projargs)

spdf_retail <- SpatialPointsDataFrame(lnglat, retail)

```

# For specific Single Tract
To test out, I randomly chose a tract in downtown Minneapolis, where more retails might be located. 

## Splitting Tracts
```{r}
tract_27053126100 <- hennepin[which(hennepin@data$GEOID10 == 27053126100), ]
```


## Points in polygon
Using the `over()` function, I filter out the retailers that are located in that specific tract. I also used `complete.cases()` to filter out the ones not in the tract.
```{r}
retail_logical <- over(spdf_retail, tract_27053126100)
count <- nrow(retail_logical[complete.cases(retail_logical[ , 5:6]),])
```



# Looping over all tracts
To loop over all the tracts in Hennepin county, I repeat the same process in a for loop.

## Count retailers for each tract
```{r}
tracts <- as.vector(hennepin@data[["GEOID10"]])
tracts <- sort(tracts)

count_vec <- c()

for (t in tracts){
  single_tract <- hennepin[which(hennepin@data$GEOID10 == t), ]
  
  retail_logical <- over(spdf_retail, single_tract)
  count <- nrow(retail_logical[complete.cases(retail_logical[ , 5:6]),])
  count_vec = c(count_vec, count)
}
```


## Convert to df
```{r}
df <- as.data.frame(cbind(tracts, count_vec))
df<- df %>% 
  rename(
    tract = tracts,
    count = count_vec)
```


## Merge to main dataframe with all other attributes
```{r warning=FALSE, message=FALSE}
data <- read_csv("2010_Census_Tracts.csv")
data <- data %>%
  select(c("GEOID10", 'NAME10', 'ALAND10', 'TRACT', 'POP_TOTAL', 'POP1_RACE',
           'POP1_WHT', 'POP1_BLK', 'POP1_AMIND', 'POP1_ASN', 'POP1_HAWPA',
           'POP1_OTHR', 'POP2_MORE', 'POP_HSPLAT', 'POP_NO_HSP', 'POPWHNOHSP', 
           'TOT_HU', 'TOT_OCCHU', 'TOT_VACHU'))
data$GEOID10 <- as.character(data$GEOID10)
data <- data %>%
  left_join(df, by=c('GEOID10' ='tract'))
```


## Store per people

```{r}

data['count'] <- as.numeric(unlist(data['count']))
data['store_per_person'] <- data['count'] / data['POP_TOTAL']
write_csv(data, "D:/UMN/06_6130 Introduction to Business Analytics in R/Hennepin County Live Case/store_per_person.csv")

```





